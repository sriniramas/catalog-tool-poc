{"version":3,"file":"i18n.service.js","sourceRoot":"","sources":["../src/i18n/i18n.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from \"@angular/core\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { merge } from \"./../utils/object\";\n\nconst EN = require(\"./en.json\");\n\n/**\n * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.\n *\n * The keys specify the variable name in the string.\n *\n * Example:\n * ```typescript\n * service.set({ \"TEST\": \"{{foo}} {{bar}}\" });\n *\n * service.replace(service.get(\"TEST\"), { foo: \"test\", bar: \"asdf\" })\n * ```\n *\n * Produces: `\"test asdf\"`\n *\n * @param subject the translation to replace variables on\n * @param variables object of variables to replace\n */\nexport const replace = (subject, variables) => subject.pipe(\n\tmap<string, void>(str => {\n\t\tconst keys = Object.keys(variables);\n\t\tfor (const key of keys) {\n\t\t\tconst value = variables[key];\n\t\t\twhile (str.includes(`{{${key}}}`)) {\n\t\t\t\tstr = str.replace(`{{${key}}}`, value);\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t})\n);\n\n/**\n * The I18n service is a minimal internal singleton service used to supply our components with translated strings.\n *\n * All the components that support I18n also support directly passed strings.\n * Usage of I18n is optional, and it is not recommended for application use (libraries like ngx-translate\n * are a better choice)\n *\n */\n@Injectable()\nexport class I18n {\n\tprotected translationStrings = EN;\n\n\tprotected translations = new Map();\n\n\t/**\n\t * Set/update the translations from an object. Also notifies all participating components of the update.\n\t *\n\t * @param strings an object of strings, should follow the same format as src/i18n/en.json\n\t */\n\tpublic set(strings) {\n\t\tthis.translationStrings = merge({}, EN, strings);\n\t\t// iterate over all our tracked translations and update each observable\n\t\tconst translations = Array.from(this.translations);\n\t\tfor (const [path, subject] of translations) {\n\t\t\tsubject.next(this.getValueFromPath(path));\n\t\t}\n\t}\n\n\t/**\n\t * When a path is specified returns an observable that will resolve to the translation string value.\n\t *\n\t * Returns the full translations object if path is not specified.\n\t *\n\t * @param path optional, looks like `\"NOTIFICATION.CLOSE_BUTTON\"`\n\t */\n\tpublic get(path?) {\n\t\tif (!path) {\n\t\t\treturn this.translationStrings;\n\t\t}\n\t\ttry {\n\t\t\t// we run this here to validate the path exists before adding it to the translation map\n\t\t\tconst value = this.getValueFromPath(path);\n\t\t\tif (this.translations.has(path)) {\n\t\t\t\treturn this.translations.get(path);\n\t\t\t}\n\t\t\tconst translation = new BehaviorSubject(value);\n\t\t\tthis.translations.set(path, translation);\n\t\t\treturn translation;\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t}\n\t}\n\n\t/**\n\t * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.\n\t *\n\t * The keys specify the variable name in the string.\n\t *\n\t * Example:\n\t * ```\n\t * service.set({ \"TEST\": \"{{foo}} {{bar}}\" });\n\t *\n\t * service.replace(service.get(\"TEST\"), { foo: \"test\", bar: \"asdf\" })\n\t * ```\n\t *\n\t * Produces: `\"test asdf\"`\n\t *\n\t * @param subject the translation to replace variables on\n\t * @param variables object of variables to replace\n\t */\n\tpublic replace(subject, variables) {\n\t\treturn replace(subject, variables);\n\t}\n\n\t/**\n\t * Trys to resolve a value from the provided path.\n\t *\n\t * @param path looks like `\"NOTIFICATION.CLOSE_BUTTON\"`\n\t */\n\tprotected getValueFromPath(path) {\n\t\tlet value = this.translationStrings;\n\t\tfor (const segment of path.split(\".\")) {\n\t\t\tif (value[segment]) {\n\t\t\t\tvalue = value[segment];\n\t\t\t} else {\n\t\t\t\tthrow new Error(`no key ${segment} at ${path}`);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n"]}